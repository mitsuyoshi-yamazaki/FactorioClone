# デザインパターン適用検討

## 概要

本ドキュメントでは、Factorioクローンプロジェクトに適用可能なデザインパターンについて調査・検討した結果をまとめる。

## 推奨デザインパターン

### 1. Entity Component System (ECS) ⭐️最重要

#### 詳細説明

ECS（エンティティ・コンポーネント・システム）は主にゲーム開発で使用されるソフトウェアアーキテクチャパターンである。従来のオブジェクト指向の継承よりも、コンポジションの原則に従うことで、より柔軟にエンティティを定義することを可能にする。

**基本構成要素**：
- **Entity（エンティティ）**: 汎用的なオブジェクトを表し、通常は一意のIDのみで構成される
- **Component（コンポーネント）**: エンティティが特定の側面を持つことを特徴付け、その側面をモデル化するために必要なデータを保持する
- **System（システム）**: 各システムはゲームの特定の側面のロジックと振る舞いを制御する

#### Factorioクローンでの適用

**Entity例**:
- プレイヤー
- ベルトコンベア
- インサータ
- 組立機
- 資源ノード

**Component例**:
```typescript
interface Position { x: number; y: number; }
interface Renderable { type: string; color: string; }
interface Inventory { items: Map<string, number>; capacity: number; }
interface Recipe { input: Item[]; output: Item[]; duration: number; }
interface PowerConsumer { consumption: number; }
interface ItemTransporter { direction: Direction; speed: number; }
```

**System例**:
- MovementSystem: Position componentを持つエンティティの移動処理
- RenderSystem: Position + Renderable componentを持つエンティティの描画
- CraftingSystem: Recipe + Inventory componentを持つエンティティの製造処理
- PowerSystem: PowerConsumer componentを持つエンティティの電力管理
- TransportSystem: ItemTransporter componentを持つエンティティのアイテム輸送

#### 実装例

```typescript
class Entity {
  private components = new Map<string, any>();

  addComponent<T>(component: T): this {
    this.components.set(component.constructor.name, component);
    return this;
  }

  getComponent<T>(type: new() => T): T | undefined {
    return this.components.get(type.name);
  }
}

// 使用例
const belt = new Entity()
  .addComponent(new Position(100, 100))
  .addComponent(new Renderable('rect', 'yellow'))
  .addComponent(new ItemTransporter(Direction.Right, 2))
  .addComponent(new PowerConsumer(1));
```

#### 参考記事
- [ECS (Entity Component System)について - Zenn](https://zenn.dev/suuta/articles/0aa567690ec52a) （日本語）
- [Unity でのゲーム開発で ECS の思想を取り入れた話](https://guinpen98.github.io/VuePress/articles/OperationR-ECS.html) （日本語）
- [エンティティ・コンポーネント・システム - Wikipedia](https://ja.wikipedia.org/wiki/エンティティ・コンポーネント・システム) （日本語）
- [The Entity-Component-System pattern | JavaScript for Games](https://jsforgames.com/ecs/) （英語）
- [Building a tiny type-safe typescript ECS - DEV Community](https://dev.to/trymnilsen/building-a-tiny-type-safe-typescript-ecs-entity-component-system-dil) （英語）

### 2. State Pattern ⭐️重要

#### 詳細説明

ステートパターンは、オブジェクトの内部状態が変わった時にオブジェクトの振る舞いを変更する行動デザインパターンである。有限状態機械（FSM）の概念と密接に関連している。

ゲーム開発において、キャラクターや機械の複雑な状態遷移を管理するのに非常に有効である。状態ごとに異なるクラスを作成し、状態に応じた振る舞いをカプセル化できる。

#### Factorioクローンでの適用

**組立機の状態管理**:
```typescript
interface AssemblerState {
  handle(assembler: Assembler): void;
  canCraft(): boolean;
}

class AssemblerIdleState implements AssemblerState {
  handle(assembler: Assembler) {
    if (assembler.hasRecipe() && assembler.hasPower() && assembler.hasInputs()) {
      assembler.setState(new AssemblerCraftingState());
    }
  }
  canCraft() { return false; }
}

class AssemblerCraftingState implements AssemblerState {
  private progress = 0;

  handle(assembler: Assembler) {
    if (!assembler.hasPower()) {
      assembler.setState(new AssemblerNoPowerState());
      return;
    }

    this.progress += assembler.getCraftingSpeed();
    if (this.progress >= assembler.getRecipe().duration) {
      assembler.produceItems();
      assembler.setState(new AssemblerIdleState());
    }
  }
  canCraft() { return true; }
}
```

**インサータの状態管理**:
- WaitingState: アイテムの出現を待機
- GrabbingState: アイテムを掴む
- MovingState: アイテムを運ぶ
- InsertingState: アイテムを配置

**ゲーム全体の状態管理**:
- PlayingState: ゲーム中
- PausedState: 一時停止
- MenuState: メニュー画面
- InventoryState: インベントリ画面

#### 参考記事
- [【TS】今さら聞けないステートパターン - Zenn](https://zenn.dev/nekoniki/articles/b039e5e553b5e95729b5) （日本語）
- [State - Refactoring Guru](https://refactoring.guru/ja/design-patterns/state) （日本語）
- [ステートパターン（State Pattern）｜Unity - level up your code](https://zenn.dev/twugo/books/21cb3a6515e7b8/viewer/b48713) （日本語）
- [📖 ステートマシンと状態遷移図について｜XStateの解説](https://zenn.dev/susiyaki/books/379ad159248627/viewer/what-is-state-machines-and-statecharts) （日本語）
- [State in TypeScript / Design Patterns](https://refactoring.guru/design-patterns/state/typescript/example) （英語）

### 3. Observer Pattern ⭐️重要

#### 詳細説明

オブザーバーパターンは、オブジェクト間の1対多の依存関係を定義する行動デザインパターンである。あるオブジェクト（Subject）の状態が変化した時に、それに依存する複数のオブジェクト（Observer）に自動的に通知される仕組みを提供する。

ゲーム開発では、イベント駆動アーキテクチャ、リアルタイム更新、pub-subメッセージングシステムに特に有用で、システム間の疎結合を実現し、モジュラーで適応可能なシステムを作ることができる。

#### Factorioクローンでの適用

**電力グリッド通知システム**:
```typescript
interface PowerObserver {
  onPowerChange(supply: number, demand: number): void;
}

class PowerGrid {
  private observers: PowerObserver[] = [];
  private supply = 0;
  private demand = 0;

  addObserver(observer: PowerObserver) {
    this.observers.push(observer);
  }

  removeObserver(observer: PowerObserver) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }

  notifyPowerChange() {
    this.observers.forEach(obs => obs.onPowerChange(this.supply, this.demand));
  }

  updatePower(newSupply: number, newDemand: number) {
    this.supply = newSupply;
    this.demand = newDemand;
    this.notifyPowerChange();
  }
}

// 機械が電力変化を監視
class Assembler implements PowerObserver {
  onPowerChange(supply: number, demand: number) {
    if (supply < demand) {
      this.setState(new AssemblerNoPowerState());
    }
  }
}
```

**EventBusパターンの実装**:
```typescript
class EventBus {
  private events = new Map<string, Function[]>();

  on(event: string, callback: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
  }

  emit(event: string, ...args: any[]) {
    if (this.events.has(event)) {
      this.events.get(event)!.forEach(callback => callback(...args));
    }
  }

  off(event: string, callback: Function) {
    if (this.events.has(event)) {
      this.events.set(event,
        this.events.get(event)!.filter(cb => cb !== callback)
      );
    }
  }
}

// 使用例
const eventBus = new EventBus();

// インベントリ変更の通知
eventBus.on('inventory-changed', (items) => {
  updateInventoryUI(items);
});

// アイテム生産の通知
eventBus.on('item-produced', (item, quantity) => {
  updateStatistics(item, quantity);
});
```

#### 適用場面
- 電力グリッドの供給/需要変動通知
- インベントリ変更のUI更新通知
- アイテム生産の統計更新通知
- プレイヤーアクションのログ記録
- 実績システムの進捗追跡

#### 参考記事
- [TypeScript で学ぶ Observer パターン | Recruit Tech Blog](https://techblog.recruit.co.jp/article-484/) （日本語）
- [オブザーバパターン完全に理解した｜erukiti](https://note.com/erukiti/n/n1d6e0fcfaefc) （日本語）
- [Observer - Refactoring Guru](https://refactoring.guru/ja/design-patterns/observer) （日本語）
- [Observer パターン - Wikipedia](https://ja.wikipedia.org/wiki/Observer_パターン) （日本語）
- [Let's Create a Lightweight Native Event Bus in JavaScript](https://css-tricks.com/lets-create-a-lightweight-native-event-bus-in-javascript/) （英語）

### 4. Factory Pattern 〇適用可能

#### 詳細説明

ファクトリーパターンは、オブジェクトの生成ロジックをクライアントから隠蔽し、共通のインターフェースを通じてオブジェクトを作成する生成デザインパターンである。特に、様々な種類のオブジェクト（敵、アイテム、設備など）を共通のインターフェースで作成する場合に有用である。

#### Factorioクローンでの適用

**エンティティファクトリ**:
```typescript
abstract class EntityFactory {
  abstract createEntity(x: number, y: number): Entity;
}

class BeltFactory extends EntityFactory {
  createEntity(x: number, y: number, direction: Direction): Entity {
    return new Entity()
      .addComponent(new Position(x, y))
      .addComponent(new Renderable('rect', 'yellow'))
      .addComponent(new ItemTransporter(direction, 2))
      .addComponent(new PowerConsumer(1));
  }
}

class InserterFactory extends EntityFactory {
  createEntity(x: number, y: number, rotation: number): Entity {
    return new Entity()
      .addComponent(new Position(x, y))
      .addComponent(new Renderable('circle', 'orange'))
      .addComponent(new InserterArm(rotation))
      .addComponent(new PowerConsumer(2));
  }
}

class AssemblerFactory extends EntityFactory {
  createEntity(x: number, y: number): Entity {
    return new Entity()
      .addComponent(new Position(x, y))
      .addComponent(new Renderable('rect', 'gray'))
      .addComponent(new Inventory(new Map(), 10))
      .addComponent(new Recipe([], [], 0))
      .addComponent(new PowerConsumer(5));
  }
}
```

#### 参考記事
- [Factory Method - Refactoring Guru](https://refactoring.guru/design-patterns/factory-method) （英語）
- [TypeScriptでファクトリーパターンを理解する](https://fireship.io/lessons/typescript-design-patterns/) （英語）

### 5. Command Pattern △限定的適用

#### 詳細説明

コマンドパターンは、リクエスト（命令）をオブジェクトとしてカプセル化し、クライアントに異なるリクエストでパラメータ化、リクエストのキューイング、ログ記録、元に戻すことを可能にする行動デザインパターンである。ゲーム開発では特に、アンドゥ・リドゥ機能やリプレイシステムの実装に有用である。

#### Factorioクローンでの適用

**プレイヤーアクション管理**:
```typescript
interface Command {
  execute(): void;
  undo(): void;
}

class PlaceEntityCommand implements Command {
  constructor(
    private world: World,
    private entityType: string,
    private x: number,
    private y: number
  ) {}

  execute() {
    this.world.placeEntity(this.entityType, this.x, this.y);
  }

  undo() {
    this.world.removeEntity(this.x, this.y);
  }
}

class RemoveEntityCommand implements Command {
  private removedEntity: Entity | null = null;

  constructor(private world: World, private x: number, private y: number) {}

  execute() {
    this.removedEntity = this.world.removeEntity(this.x, this.y);
  }

  undo() {
    if (this.removedEntity) {
      this.world.placeEntity(this.removedEntity, this.x, this.y);
    }
  }
}
```

#### 参考記事
- [Command - Game Programming Patterns](https://gameprogrammingpatterns.com/command.html) （英語）
- [Decoupling your game code via Command pattern](https://medium.com/gamedev-architecture/decoupling-game-code-via-command-pattern-debugging-it-with-time-machine-2b177e61556c) （英語）

## 推奨アーキテクチャ構成

### メインアーキテクチャ: ECS + State + Observer

```typescript
interface GameArchitecture {
  world: World;                    // ECS World
  systems: System[];               // ECS Systems
  stateManager: StateManager;      // State Pattern
  eventBus: EventBus;             // Observer Pattern
  entityFactories: Map<string, EntityFactory>; // Factory Pattern
}

class FactorioClone {
  private world = new World();
  private systems = [
    new MovementSystem(),
    new CraftingSystem(),
    new PowerSystem(),
    new TransportSystem(),
    new RenderSystem()
  ];
  private stateManager = new GameStateManager();
  private eventBus = new EventBus();
  private entityFactories = new Map<string, EntityFactory>();

  constructor() {
    this.initializeFactories();
    this.setupEventListeners();
  }

  private initializeFactories() {
    this.entityFactories.set('belt', new BeltFactory());
    this.entityFactories.set('inserter', new InserterFactory());
    this.entityFactories.set('assembler', new AssemblerFactory());
  }

  private setupEventListeners() {
    this.eventBus.on('power-changed', (supply, demand) => {
      this.systems.forEach(system => {
        if (system instanceof PowerSystem) {
          system.handlePowerChange(supply, demand);
        }
      });
    });
  }

  update(deltaTime: number) {
    this.systems.forEach(system => system.update(deltaTime));
    this.stateManager.update();
  }
}
```

## 段階的導入アプローチ

### Phase 1: シンプル開始
- 基本的なクラス設計でプロトタイプ作成
- Observer PatternでEventBusを実装し、最低限のイベント処理

### Phase 2: ECS導入
- ゲームオブジェクトの複雑化に伴いECS導入
- State Patternで機械の状態管理追加

### Phase 3: 完全なパターン適用
- 全システムの統合とパフォーマンス最適化
- Factory Patternでコードの整理
- Command Patternで高度な機能追加（オプション）

## 利点とリスク

### 利点
- **ECS**: ゲームオブジェクトの柔軟な組み合わせと高いパフォーマンス
- **State Pattern**: 複雑な機械の状態管理の明確化
- **Observer Pattern**: システム間の疎結合な通信
- **Factory Pattern**: 統一されたエンティティ生成とメンテナンス性向上

### リスク・注意点
- **ECS学習コスト**: 従来のOOPと異なる思考が必要
- **過度な設計**: シンプルな部分には適用せず、必要な箇所のみ使用
- **パフォーマンス**: 適切な実装が重要（特にECSのシステム設計）
- **デバッグの複雑性**: 複数のパターンが相互作用する場合の追跡が困難

## 結論

本プロジェクトでは、**ECS + State + Observer**を核とした段階的なアーキテクチャ導入を推奨する。これにより、Factorioの複雑なシステム間相互作用を効率的に管理し、TypeScriptの型安全性を活かした保守性の高い実装が可能になる。